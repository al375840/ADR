---
import '../../public/styles/global.css'; // Ajusta la ruta si es necesario
---

<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Portfolio Adrián</title>
    <!-- Importar la fuente 'Press Start 2P' desde Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="container"></div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const container = document.getElementById('container');
        let numCols: number, numRows: number;
        let occupiedPositions: { row: any; col: any; }[] = [];
        let textSquares: { row: number; col: number; letter: string; }[] = [];

        const images = [
          {
            src: '/images/portrait.png',
            alt: 'Descripción de la imagen',
            width: 5,
            height: 8,
            col: 2,
            row: 2,
          },
        ];

        const texts = [
          {
            content: "ADRIAN",
            col: 2,
            row: 2,
          },
          {
            content: "IT ENGINEER",
            col: 2,
            row: 4,
          },
        ];

        const cards = [
          {
            content: 'Este es el texto de la primera tarjeta.',
            width: 10,
            height: 4,
            col: 2,
            row: 11,
          },
        ];

        function generateSquares() {
          if (!container) {
            throw new Error("El elemento 'container' no se encontró en el DOM.");
          }

          container.innerHTML = ''; // Limpia los cuadrados existentes

          const minSize = 60; // Tamaño mínimo de los cuadrados

          const availableWidth = window.innerWidth;
          const availableHeight = window.innerHeight;

          // Calcula el número de columnas y filas basándose en el tamaño mínimo
          numCols = Math.floor(availableWidth / minSize);
          numRows = Math.floor(availableHeight / minSize);

          // Ajusta el grid para que tenga el número correcto de columnas
          container.style.display = 'grid';
          container.style.width = '100vw';
          container.style.height = '100vh';
          container.style.gridTemplateColumns = `repeat(${numCols}, 1fr)`;
          container.style.gridAutoRows = `minmax(${minSize}px, 1fr)`;

          occupiedPositions = [];
          textSquares = [];

          createImageElements();
          createTextElements();
          createCardElements();
          generateGridSquares();
        }

        function isPositionOccupied(row: number, col: number) {
          return occupiedPositions.some(
            (pos) => pos.row === row && pos.col === col
          );
        }

        function markPositionAsOccupied(row: number, col: number) {
          if (row > 0 && row <= numRows && col > 0 && col <= numCols) {
            occupiedPositions.push({ row, col });
          }
        }

        function createTextElements() {
          texts.forEach((textItem) => {
            let { content, col, row } = textItem;

            if (col == null) {
              const textLength = content.replace(/\s/g, '').length;
              col = Math.floor((numCols - textLength) / 2) + 1;
              col = Math.max(col, 1);
              textItem.col = col;
            }

            if (row == null) {
              row = Math.floor(numRows / 2);
              row = Math.max(row, 1);
              textItem.row = row;
            }

            let currentCol = col;

            for (let i = 0; i < content.length; i++) {
              const char = content[i];
              if (char !== ' ') {
                if (!isPositionOccupied(row, currentCol)) {
                  markPositionAsOccupied(row, currentCol);
                  textSquares.push({ row, col: currentCol, letter: char });
                } else {
                  console.warn(
                    `La posición (${row}, ${currentCol}) ya está ocupada.`
                  );
                }
                currentCol++;
              } else {
                currentCol++;
              }
            }
          });
        }

        function createCardElements() {
          cards.forEach((cardItem) => {
            let { content, width, height, col, row } = cardItem;

            if (col == null) {
              col = Math.floor((numCols - width) / 2) + 1;
              col = Math.max(col, 1);
              cardItem.col = col;
            }

            if (row == null) {
              const maxTextRow = texts.reduce(
                (max, textItem) => Math.max(max, textItem.row),
                0
              );
              row = maxTextRow + 2; // Dejar una fila de espacio
              row = Math.max(row, 1);
              cardItem.row = row;
            }

            const endRow = row + height - 1;
            const endCol = col + width - 1;

            // Verificar si las posiciones están ocupadas
            let canPlace = true;
            for (let r = row; r <= endRow; r++) {
              for (let c = col; c <= endCol; c++) {
                if (isPositionOccupied(r, c)) {
                  console.warn(
                    `La posición (${r}, ${c}) ya está ocupada. La tarjeta no puede ser colocada.`
                  );
                  canPlace = false;
                  break;
                }
              }
              if (!canPlace) break;
            }

            if (canPlace) {
              // Marcar posiciones como ocupadas
              for (let r = row; r <= endRow; r++) {
                for (let c = col; c <= endCol; c++) {
                  markPositionAsOccupied(r, c);
                }
              }
              createCard(cardItem);
            }
          });
        }

        function createImageElements() {
          images.forEach((imageItem) => {
            let { src, alt, width, height, col, row } = imageItem;

            if (col == null) {
              col = Math.floor((numCols - width) / 2) + 1;
              col = Math.max(col, 1);
              imageItem.col = col;
            }

            if (row == null) {
              const maxCardRow = cards.reduce(
                (max, cardItem) => Math.max(max, cardItem.row + cardItem.height - 1),
                0
              );
              row = maxCardRow + 2; // Dejar una fila de espacio
              row = Math.max(row, 1);
              imageItem.row = row;
            }

            const endRow = row + height - 1;
            const endCol = col + width - 1;

            // Verificar si las posiciones están ocupadas
            let canPlace = true;
            for (let r = row; r <= endRow; r++) {
              for (let c = col; c <= endCol; c++) {
                if (isPositionOccupied(r, c)) {
                  console.warn(
                    `La posición (${r}, ${c}) ya está ocupada. La imagen no puede ser colocada.`
                  );
                  canPlace = false;
                  break;
                }
              }
              if (!canPlace) break;
            }

            if (canPlace) {
              // Marcar posiciones como ocupadas
              for (let r = row; r <= endRow; r++) {
                for (let c = col; c <= endCol; c++) {
                  markPositionAsOccupied(r, c);
                }
              }
              createImage(imageItem);
            }
          });
        }

        function createCard(cardData: { content: any; width: any; height: any; col: any; row: any; }) {
          const { content, row, col, width, height } = cardData;

          const card = document.createElement('div');
          card.className = 'card';

          card.style.gridRow = `${row} / ${row + height}`;
          card.style.gridColumn = `${col} / ${col + width}`;

          card.innerHTML = `<p>${content}</p>`;

          container.appendChild(card);
        }

        function createImage(imageData: { src: any; alt: any; width: any; height: any; col: any; row: any; }) {
          const { src, alt, row, col, width, height } = imageData;

          const imgWrapper = document.createElement('div');
          imgWrapper.className = 'image-wrapper';

          imgWrapper.style.gridRow = `${row} / ${row + height}`;
          imgWrapper.style.gridColumn = `${col} / ${col + width}`;

          const img = document.createElement('img');
          img.src = src;
          img.alt = alt;
          img.style.width = '100%';
          img.style.height = '100%';
          img.style.objectFit = 'cover';

          imgWrapper.appendChild(img);
          container.appendChild(imgWrapper);
        }

        function generateGridSquares() {
          const totalPositions = [];
          for (let row = 1; row <= numRows; row++) {
            for (let col = 1; col <= numCols; col++) {
              const isOccupied = isPositionOccupied(row, col);
              if (!isOccupied) {
                totalPositions.push({ row, col });
              }
            }
          }

          shuffle(totalPositions);

          const numLighterSquares = Math.floor(totalPositions.length * 0.3);
          const lighterPositions = totalPositions.slice(0, numLighterSquares);

          for (let row = 1; row <= numRows; row++) {
            for (let col = 1; col <= numCols; col++) {
              const square = document.createElement('div');
              square.className = 'square';

              square.classList.add(`row-${row}`, `col-${col}`);

              const textSquare = textSquares.find(
                (item) => item.row === row && item.col === col
              );

              if (textSquare) {
                square.textContent = textSquare.letter;
                square.classList.add('text-square');
              } else {
                const isLighter = lighterPositions.some(
                  (pos) => pos.row === row && pos.col === col
                );

                if (isLighter) {
                  square.classList.add('lighter');
                }
              }

              container.appendChild(square);
            }
          }
        }

        function shuffle(array: string | any[]) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }

        window.addEventListener('resize', generateSquares);
        generateSquares();
      });
    </script>
  </body>
</html>
